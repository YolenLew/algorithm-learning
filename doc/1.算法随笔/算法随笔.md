# 算法随笔

## 核心框架

### 回溯算法

- 组合、子集问题：使用 `start` 变量保证元素 `nums[start]` 之后只会出现 `nums[start+1..]` 中的元素，通过固定元素的相对位置保证不出现重复的子集。

  - **标准的子集/组合问题是如何保证不重复使用元素的**？答案在于 `backtrack` 递归时输入的参数 `start`：

  ```java
  // 无重组合的回溯算法框架
  void backtrack(int[] nums, int start) {
      for (int i = start; i < nums.length; i++) {
          // ...
          // 递归遍历下一层回溯树，注意参数
          backtrack(nums, i + 1);
          // ...
      }
  }
  ```

  

- 子集：子集过程可以类比一颗树，然后把所有树上的节点收集就是所有的子集结果。

- **排列问题**：本身就是让你穷举元素的位置，`nums[i]` 之后也可以出现 `nums[i]` 左边的元素，所以之前的那一套玩不转了，需要额外使用 `used` 数组来标记哪些元素还可以被选择。

  - 通过`*boolean[] used`数组进行标记

- 排列剪枝问题：

  - `[1,2,2']` 和 `[1,2',2]` 应该只被算作同一个排列
  - 如何设计剪枝逻辑，把这种重复去除掉：**答案是，保证相同元素在排列中的相对位置保持不变**。
  - **标准全排列算法之所以出现重复，是因为把相同元素形成的排列序列视为不同的序列，但实际上它们应该是相同的；而如果固定相同元素形成的序列顺序，当然就避免了重复**。
  - **当出现重复元素时，比如输入 `nums = [1,2,2',2'']`，`2'` 只有在 `2` 已经被使用的情况下才会被选择，同理，`2''` 只有在 `2'` 已经被使用的情况下才会被选择，这就保证了相同元素在排列中的相对位置保证固定**。
  - 参考：[回溯算法秒杀所有排列-组合-子集问题-labuladong](https://labuladong.online/algo/essential-technique/permutation-combination-subset-all-in-one/#%E6%8E%92%E5%88%97-%E5%85%83%E7%B4%A0%E5%8F%AF%E9%87%8D%E4%B8%8D%E5%8F%AF%E5%A4%8D%E9%80%89)

  ```java
  // 新添加的剪枝逻辑，固定相同的元素在排列中的相对位置
  if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
      // 如果前面的相邻相等元素没有用过，则跳过
      continue;
  }
  // 选择 nums[i]
  ```

  



# 二分搜索



## 左侧边界问题

- 左侧边界的二分算法的细节理解

```properties
当目标元素 target 不存在数组 nums 中时，搜索左侧边界的二分搜索的返回值可以做以下几种解读：

1、返回的这个值是 nums 中大于等于 target 的最小元素索引。

2、返回的这个值是 target 应该插入在 nums 中的索引位置。

3、返回的这个值是 nums 中小于 target 的元素个数。

比如在有序数组 nums = [2,3,5,7] 中搜索 target = 4，搜索左边界的二分算法会返回 2，你带入上面的说法，都是对的。

所以以上三种解读都是等价的
```





# 数组

## 二位数组

- 把二维数组 `matrix` 的元素访问抽象成在一维数组中访问元素：只要知道二维数组的的行数 `m` 和列数 `n`，二维数组的坐标 `(i, j)` 可以映射成一维的 `index = i * n + j`；反过来也可以通过一维 `index` 反解出二维坐标 `i = index / n, j = index % n`。

```java
// 把二维数组映射到一维
int left = 0, right = m * n - 1;

// 通过一维坐标访问二维数组中的元素
    int get(int[][] matrix, int index) {
        int m = matrix.length, n = matrix[0].length;
        // 计算二维中的横纵坐标
        int i = index / n, j = index % n;
        return matrix[i][j];
    }
```





# 动态规划

## 解法思路

- 状态四步法：
  1. 明确【状态】：如何才能描述一个问题局面？
  2. 明确【选择】：针对每件物品，能选择什么？
  3. 明确dp数组定义：一般来说，状态有几种，就需要几维数组
  4. 根据选择，思考状态转移方程（递推关系）
  5. 把伪代码翻译成代码，处理边界情况
  6. 初始状态（base case定义）

- 怎么定义dp[i]？
  - 我们试着拆分子问题，目光盯着子问题与大问题之间的联系
  - 感受一下“提供”这词：前一个子问题的解可以“提供”给后一个子问题多大的有效长度。后一个子问题的解，要想纳入前面“提供”的有效长度，则前面子串的末尾必须是有效子串的一部分。（连续性）
  - 子问题dp[i]：以s[i]为结尾的子串中，所形成的最长有效子串的长度，且有效子串是以s[i]为结尾。
  - 规定有效子串是以s[i]为结尾，这样才能“提供”给后一个子问题一段有效长度

> 作者：笨猪爆破组
> 链接：https://leetcode.cn/problems/longest-valid-parentheses/solutions/314827/shou-hua-tu-jie-zhan-de-xiang-xi-si-lu-by-hyj8/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 定义状态转移关系

- 参考：[动态规划设计：最长递增子序列](https://labuladong.online/algo/dynamic-programming/longest-increasing-subsequence/#%E4%B8%80%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%A7%A3%E6%B3%95)

- 总结一下如何找到动态规划的状态转移关系：

  1、明确 `dp` 数组的定义。这一步对于任何动态规划问题都很重要，如果不得当或者不够清晰，会阻碍之后的步骤。

  2、根据 `dp` 数组的定义，运用数学归纳法的思想，假设 `dp[0...i-1]` 都已知，想办法求出 `dp[i]`，一旦这一步完成，整个题目基本就解决了。

  3、但如果无法完成这一步，很可能就是 `dp` 数组的定义不够恰当，需要重新定义 `dp` 数组的含义；或者可能是 `dp` 数组存储的信息还不够，不足以推出下一步的答案，需要把 `dp` 数组扩大成二维数组甚至三维数组。



























